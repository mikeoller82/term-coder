from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional

import re


@dataclass
class GeneratedFile:
    path: Path
    content: str
    validated: bool
    message: str


# Simple template registry: (framework, kind) -> template string
# Placeholders: {{Name}}, {{name_snake}}, {{name_kebab}}, {{name_camel}}
TEMPLATES: Dict[tuple[str, str], str] = {
    ("python", "module"): (
        '''"""
{{Name}} module.

This module was generated by Term Coder. It exports a simple function
and a dataclass to get you started.
"""
from __future__ import annotations

from dataclasses import dataclass


@dataclass
class {{Name}}Config:
    enabled: bool = True


def {{name_snake}}_run(config: {{Name}}Config) -> str:
    """Execute the core logic for {{Name}}.

    Args:
        config: Configuration for the {{Name}} run.

    Returns:
        A status string indicating success.
    """
    if not config.enabled:
        return "{{Name}} disabled"
    return "{{Name}} completed successfully"
'''
    ),
    ("react", "component"): (
        """import React from 'react';

type {{Name}}Props = {
  title?: string;
};

export default function {{Name}}({ title = '{{Name}}' }: {{Name}}Props) {
  return (
    <div className="{{name_kebab}}-component">
      <h2>{title}</h2>
    </div>
  );
}
"""
    ),
    ("node", "script"): (
        """#!/usr/bin/env node

// {{Name}} script generated by Term Coder.
// Usage: {{name_kebab}} [args]

function main(argv) {
  if (argv.includes('--help')) {
    console.log('Usage: {{name_kebab}} [args]');
    process.exit(0);
  }
  console.log('{{Name}} script ran successfully');
}

if (require.main === module) {
  main(process.argv.slice(2));
}
"""
    ),
}


def to_snake(name: str) -> str:
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    s2 = re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1)
    return s2.replace("-", "_").lower()


def to_kebab(name: str) -> str:
    return to_snake(name).replace("_", "-")


def to_camel(name: str) -> str:
    parts = re.split(r"[_\-\s]+", name)
    return parts[0].lower() + "".join(p.capitalize() for p in parts[1:])


def render_template(template: str, name: str) -> str:
    return (
        template.replace("{{Name}}", name)
        .replace("{{name_snake}}", to_snake(name))
        .replace("{{name_kebab}}", to_kebab(name))
        .replace("{{name_camel}}", to_camel(name))
    )


def default_filename(framework: str, kind: str, name: str) -> str:
    if framework == "python" and kind == "module":
        return f"{to_snake(name)}.py"
    if framework == "react" and kind == "component":
        return f"{name}.tsx"
    if framework == "node" and kind == "script":
        return f"{to_kebab(name)}.js"
    return f"{to_kebab(name)}.txt"


def validate_generated(framework: str, kind: str, content: str, name: str) -> tuple[bool, str]:
    try:
        if framework == "python" and kind == "module":
            compile(content, "<generated>", "exec")
            return True, "Python syntax OK"
        if framework == "react" and kind == "component":
            ok = f"export default function {name}" in content
            return (ok, "Found exported component" if ok else "Exported component signature missing")
        if framework == "node" and kind == "script":
            ok = "#!/usr/bin/env node" in content and "function main(" in content
            return (ok, "Node script structure OK" if ok else "Node script header/main missing")
    except Exception as e:
        return False, f"Validation error: {e}"
    return False, "Unknown framework/kind for validation"


def generate(
    framework: str,
    kind: str,
    name: str,
    out_dir: Optional[Path] = None,
    force: bool = False,
) -> GeneratedFile:
    out_dir = (out_dir or Path.cwd()).resolve()
    key = (framework, kind)
    if key not in TEMPLATES:
        raise ValueError(f"No template for framework={framework} kind={kind}")
    template = TEMPLATES[key]
    content = render_template(template, name)
    filename = default_filename(framework, kind, name)
    dest = out_dir / filename
    if dest.exists() and not force:
        raise FileExistsError(f"File already exists: {dest}")
    dest.parent.mkdir(parents=True, exist_ok=True)
    dest.write_text(content)
    ok, msg = validate_generated(framework, kind, content, name)
    return GeneratedFile(path=dest, content=content, validated=ok, message=msg)
